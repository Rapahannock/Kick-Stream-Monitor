<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Kick & Twitch Monitor v7.1</title>
  <meta name="description" content="Monitor your favorite Kick, Twitch, and YouTube streamers with real-time updates, AI-powered summaries, and enhanced accessibility">
  <meta name="theme-color" content="#0a0a0a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0a0a0a; /* Flat, deep black */
      --bg-secondary: rgba(22, 27, 34, 0.75); /* Semi-transparent for glass effect */
      --bg-tertiary: #21262d;
      --text-primary: #e6edf3;
      --text-secondary: #8b949e;
      --border-primary: rgba(48, 54, 61, 0.8);
      --border-secondary: #8b949e;
      --accent-primary: #22d3ee; /* Vibrant Cyan */
      --accent-secondary: #67e8f9; /* Lighter Cyan */
      --live: #22c55e;
      --twitch: #9146ff; /* Twitch Purple */
      --youtube: #ff0000; /* YouTube Red */
      --offline: #f85149;
      --warning: #f59e0b;
      --info: #3b82f6;
      --shadow-sm: 0 1px 2px rgba(0,0,0,.15);
      --shadow-md: 0 4px 12px rgba(0,0,0,.25);
      --shadow-lg: 0 10px 30px rgba(0,0,0,.35);
      --radius-md: 12px;
      --radius-lg: 16px;
      --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --transition-fast: 0.15s ease;
      --transition-slow: 0.3s ease-out;
      --ring: 0 0 0 3px color-mix(in srgb, var(--accent-primary) 25%, transparent);
    }

    [data-theme="light"] {
      --bg-primary: #f0f2f5;
      --bg-secondary: rgba(255, 255, 255, 0.7);
      --bg-tertiary: #e1e4e8;
      --text-primary: #24292e;
      --text-secondary: #586069;
      --border-primary: rgba(209, 213, 218, 0.8);
      --border-secondary: #959da5;
      --accent-primary: #0366d6;
      --accent-secondary: #2188ff;
      --shadow-sm: 0 1px 2px rgba(10,10,10,.04);
      --shadow-md: 0 4px 12px rgba(10,10,10,.08);
      --shadow-lg: 0 10px 30px rgba(10,10,10,.1);
    }

    *, *::before, *::after { box-sizing: border-box; }

    body {
      color-scheme: light dark;
      font-family: var(--font-family);
      background-color: var(--bg-primary);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100' viewBox='0 0 100 100'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
      color: var(--text-primary);
      margin: 0;
      line-height: 1.5;
      padding: 20px 20px 120px 20px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      transition: background var(--transition-slow), color var(--transition-slow);
    }

    #app-container { max-width: 1800px; margin: 0 auto; }
    
    main#main-content { margin-top: 0; }
    #streamers { display: grid; gap: 20px; }
    #streamers.grid-view { grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); }
    #streamers.list-view, #streamers.compact-view { grid-template-columns: 1fr; }

    /* Streamer Card */
    .streamer {
      background: var(--bg-secondary);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--border-primary);
      border-left: 4px solid transparent;
      border-radius: var(--radius-lg);
      display: flex; flex-direction: column;
      transition: transform var(--transition-slow), box-shadow var(--transition-slow), border-color var(--transition-slow);
      position: relative;
      overflow: hidden; /* Changed from visible to fix corner bug */
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--text-primary) 7%, transparent), 0 2px 8px rgba(0,0,0,0.2);
    }
    .streamer.live.kick { border-left-color: var(--live); box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--text-primary) 7%, transparent), -5px 0 30px -8px color-mix(in srgb, var(--live) 75%, transparent), 0 2px 8px rgba(0,0,0,0.2); }
    .streamer.live.twitch { border-left-color: var(--twitch); box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--text-primary) 7%, transparent), -5px 0 30px -8px color-mix(in srgb, var(--twitch) 75%, transparent), 0 2px 8px rgba(0,0,0,0.2); }
    .streamer.live.youtube { border-left-color: var(--youtube); box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--text-primary) 7%, transparent), -5px 0 30px -8px color-mix(in srgb, var(--youtube) 75%, transparent), 0 2px 8px rgba(0,0,0,0.2); }
    
    .streamer.actions-open {
        z-index: 100; /* Bring card to front when drawer is open */
        overflow: visible; /* Temporarily allow overflow when open */
    }

    .streamer:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-lg);
      border-color: var(--border-secondary);
    }
    .streamer.selected { border-color: var(--accent-primary); box-shadow: var(--ring); }
    .streamer.favorite::before {
        content: '★';
        position: absolute;
        top: 12px;
        left: 12px;
        z-index: 3;
        color: gold;
        font-size: 20px;
        text-shadow: 0 0 8px rgba(0,0,0,0.7);
    }
     .streamer-checkbox{position:absolute;top:12px;right:12px;width:24px;height:24px;cursor:pointer;z-index:10;}

    .thumbnail-container { position: relative; cursor: pointer; border-radius: var(--radius-lg) var(--radius-lg) 0 0; overflow:hidden;}
    .thumbnail-preview {
      display: block; width: 100%; aspect-ratio: 16/9;
      object-fit: cover; background: var(--bg-tertiary);
      transition: transform var(--transition-slow);
    }
    .streamer:hover .thumbnail-preview { transform: scale(1.05); }
    
    .live-indicator {
      position: absolute; top: 12px; right: 12px;
      display: flex; align-items: center; gap: 6px;
      background: var(--live); color: white;
      padding: 4px 10px; border-radius: 99px;
      font-size: 0.8rem; font-weight: 700;
      box-shadow: 0 0 10px color-mix(in srgb, var(--live) 50%, transparent);
    }
    .live-indicator::before {
      content: ''; display: block; width: 8px; height: 8px;
      background: white; border-radius: 50%;
      animation: pulse 2s infinite;
    }
    .streamer.twitch .live-indicator {
      background: var(--twitch);
      box-shadow: 0 0 10px color-mix(in srgb, var(--twitch) 50%, transparent);
    }
    .streamer.youtube .live-indicator {
      background: var(--youtube);
      box-shadow: 0 0 10px color-mix(in srgb, var(--youtube) 50%, transparent);
    }

    .streamer-content { padding: 16px; background: transparent; position: relative;}
    .streamer-header { display: flex; align-items: center; gap: 12px; }
    .streamer-avatar { width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; border: 2px solid var(--border-primary); }
    .streamer-name-wrapper { flex: 1; }
    .streamer-name {
      font-weight: 700; font-size: 1.1rem; line-height: 1.2;
      color: var(--text-primary); text-decoration: none;
      display: flex; align-items: center; gap: 6px;
    }
    .streamer-name:hover { color: var(--accent-primary); }
    .platform-icon { width: 16px; height: 16px; opacity: 0.8; }
    .stream-meta { font-size: 0.8rem; color: var(--text-secondary); }
    .stream-title {
      font-size: 0.9rem; color: var(--text-secondary);
      margin-top: 8px; line-height: 1.4;
      display: -webkit-box; -webkit-line-clamp: 2;
      -webkit-box-orient: vertical; overflow: hidden;
    }
    .stream-category {
      display: inline-block; margin-top: 12px;
      font-size: 0.8rem; font-weight: 600; color: var(--accent-primary);
      background: color-mix(in srgb, var(--accent-primary) 15%, transparent);
      padding: 4px 12px; border-radius: 99px;
    }
    
    .streamer.list-view { flex-direction: row; align-items: center; padding: 12px; }
    .streamer.list-view .thumbnail-container { flex-basis: 160px; flex-shrink: 0; border-radius: var(--radius-md); overflow: hidden; }
    .streamer.list-view .streamer-content { padding: 0 16px; flex: 1; }
    .streamer.list-view .streamer-actions-wrapper { margin-left: auto; display: flex; margin-top: 0; }
    
    /* Action Drawer */
    .streamer-actions-wrapper { position: absolute; top: 16px; right: 16px; }
    .action-menu-toggle {
        width: 36px; height: 36px; border-radius: 50%;
        background: var(--bg-tertiary); color: var(--text-secondary);
        border: 1px solid var(--border-primary);
        cursor: pointer; font-size: 1.2rem; line-height: 1;
        transition: all var(--transition-fast);
    }
    .action-menu-toggle:hover { background: var(--border-primary); color: var(--text-primary); }
    .actions-drawer {
        position: absolute; right: 0; top: 42px; z-index: 10;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-lg);
        padding: 6px;
        display: flex;
        flex-direction: column;
        gap: 4px;
        opacity: 0;
        transform: translateY(-10px) scale(0.95);
        pointer-events: none;
        transition: all var(--transition-fast);
    }
    .streamer.actions-open .actions-drawer {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
    }
    .action-btn {
        display: flex; align-items: center; gap: 8px;
        width: 100%;
        padding: 8px 12px;
        background: transparent; color: var(--text-secondary);
        border: none; border-radius: 8px;
        font-weight: 600; font-size: 0.85rem; text-align: left;
        cursor: pointer; transition: all var(--transition-fast);
    }
    .action-btn:hover { background: var(--bg-secondary); color: var(--text-primary); }
    .action-btn.favorite.active { color: gold; }
    .action-btn.remove { color: var(--offline); }

    /* Floating Bar */
    .floating-bar {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1100;
      background: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 12px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-primary);
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--text-primary) 10%, transparent), var(--shadow-lg);
      display: flex;
      align-items: center;
      gap: 12px;
      width: max-content;
      max-width: calc(100% - 32px);
    }
    .floating-bar-section { display: flex; align-items: center; gap: 8px; }
    .app-title {
      margin: 0 8px; font-weight: 800;
      font-size: 1.1rem;
      background-image: linear-gradient(90deg, var(--accent-secondary), var(--accent-primary));
      -webkit-background-clip: text; background-clip: text; color: transparent;
      white-space: nowrap;
    }
    .app-title small { color: var(--text-secondary); font-weight: 600; font-size: 0.7em; }
    .view-controls .button, .view-controls button, .view-controls .view-toggle {
        background: var(--bg-tertiary); border: 1px solid transparent;
        color: var(--text-secondary); padding: 8px 14px;
        border-radius: 10px; font-weight: 600; cursor: pointer;
        transition: all var(--transition-fast);
    }
    .view-controls button:hover, .view-controls .view-toggle:hover { background: var(--border-primary); color: var(--text-primary); }
    .view-controls button.active, .view-controls .view-toggle.active {
        background: var(--accent-primary); color: white;
    }

    .bulk-actions {display: none; background: transparent; border: none; padding: 0; gap: 8px; align-items: center; flex-wrap: wrap;}
    .bulk-actions.visible {display: flex;}
    .selection-count {font-size: 1rem; color: var(--accent-primary); font-weight: 700;}

    .settings-panel {
      position: fixed; top: 0; right: 0; bottom: 0;
      width: clamp(320px, 40vw, 450px);
      background: var(--bg-secondary); 
      padding: 24px;
      border-left: 1px solid var(--border-primary);
      box-shadow: var(--shadow-lg);
      transform: translateX(100%);
      transition: transform var(--transition-slow);
      z-index: 1300;
      overflow-y: auto;
    }
    .settings-panel.expanded { transform: translateX(0); }
    .settings-grid {display: grid; grid-template-columns: 1fr; gap: 24px;}
    .setting-group {display: flex; flex-direction: column; gap: 8px;}
    .setting-group label {font-weight: 600; font-size: 0.9rem;}

    input, select {
        background: var(--bg-tertiary); color: var(--text-primary);
        border: 1px solid var(--border-primary); border-radius: 10px;
        padding: 12px; font-size: 1rem; width: 100%;
        transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }
    input:focus-visible, select:focus-visible { outline: none; border-color: var(--accent-primary); box-shadow: var(--ring); }
    
    @keyframes pulse { 0%,100% { opacity: 1; transform: scale(1); } 50% { opacity: .6; transform: scale(0.9); } }
    
    .empty-state, .error-state { text-align:center; padding: 60px 20px; background: var(--bg-secondary); border-radius: var(--radius-lg); margin-top: 16px; border: 1px solid var(--border-primary); }
    .empty-state h3, .error-state h3 { margin: 0 0 16px 0; font-size: 1.5rem; }
    .error-state h3 { color: var(--offline); }

    /* Modal Styles */
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,.7);
      display: none; align-items: center; justify-content: center;
      z-index: 2000; backdrop-filter: blur(8px);
    }
    .modal-overlay.visible { display: flex; }
    #settings-overlay { z-index: 1250; }
    .modal-content {
      background: var(--bg-secondary); padding: 24px;
      border-radius: var(--radius-lg); border: 1px solid var(--border-primary);
      box-shadow: var(--shadow-lg); max-width: 90vw; width: 500px;
      position: relative;
    }
    #thumbnail-modal .modal-content {
        background: transparent;
        border: none;
        box-shadow: none;
        padding: 0;
        width: auto;
        animation: modal-fade-in 0.3s ease;
    }
    #enlarged-thumbnail {
        display: block;
        max-width: 85vw;
        max-height: 85vh;
        border-radius: var(--radius-md);
        cursor: pointer;
        border: 2px solid var(--border-primary);
    }

    .modal-close {
      position: absolute; top: 12px; right: 12px; background: none; border: none;
      font-size: 24px; cursor: pointer; color: var(--text-secondary);
      padding: 4px; line-height: 1; border-radius: 8px;
    }
    .modal-close:hover { color: var(--text-primary); }
    #gemini-modal-content { margin-top: 16px; min-height: 80px; }

    /* Spinner for Gemini Loading */
    .spinner {
      border: 4px solid var(--border-primary);
      border-top: 4px solid var(--accent-primary);
      border-radius: 50%;
      width: 40px; height: 40px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes modal-fade-in { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    
     #toast{visibility:hidden;background:var(--bg-tertiary);color:var(--text-primary);text-align:center;border-radius:var(--radius-md);padding:16px 24px;position:fixed;bottom:24px;left:50%;transform:translate(-50%, calc(100% + 24px));z-index:3001;box-shadow:var(--shadow-lg);opacity:0;transition:transform .3s ease, opacity .3s ease;max-width:90%;width:420px;border:1px solid var(--border-primary);cursor:pointer;}
     #toast.show{visibility:visible;opacity:1;transform:translate(-50%, 0);}
     #toast.success{background:var(--live);color:#fff}
     #toast.error{background:var(--offline);color:#fff}
     #toast.warning{background:var(--warning);color:#fff}
     #toast.info{background:var(--info);color:#fff}
    
     @media (max-width: 768px) {
        .app-title, #last-updated { display: none; }
     }
  </style>
</head>
<body data-theme="dark">
  <div id="app-container">
    
    <main id="main-content">
      <div id="streamers" class="grid-view" role="grid"></div>
    </main>
    
    <div id="settings-overlay" class="modal-overlay"></div>
    <section class="settings-panel" id="settings-panel">
        <div class="settings-grid">
            <div class="setting-group">
            <label for="search-input">Search / Filter</label>
            <input type="text" id="search-input" placeholder="Name, category, title...">
            </div>
            <div class="setting-group">
            <label for="filter-select">View</label>
            <select id="filter-select"></select>
            </div>
            <div class="setting-group">
            <label for="sort-select">Sort By</label>
            <select id="sort-select">
                <option value="status">Live Status</option>
                <option value="viewers">Viewer Count</option>
                <option value="name">Name (A-Z)</option>
                <option value="category">Category</option>
                <option value="uptime">Stream Duration</option>
            </select>
            </div>
            <div class="setting-group">
                <label for="auto-refresh-select">Auto Refresh</label>
                <select id="auto-refresh-select">
                    <option value="0">Off</option>
                    <option value="5000">5 seconds</option>
                    <option value="30000">30 seconds</option>
                    <option value="60000">1 minute</option>
                    <option value="300000" selected>5 minutes</option>
                    <option value="600000">10 minutes</option>
                </select>
            </div>
            <div class="setting-group">
            <label for="add-input">Add Streamer</label>
            <div style="display: flex; gap: 8px;">
                <input type="text" id="add-input" placeholder="Enter streamer name" style="flex: 1;">
                <select id="platform-select" style="flex-basis: 100px;">
                    <option value="kick" selected>Kick</option>
                    <option value="twitch">Twitch</option>
                    <option value="youtube">YouTube</option>
                </select>
                <button id="add-btn" style="flex-basis: 80px;" class="button primary">Add</button>
            </div>
            </div>
        </div>
        <div class="action-buttons" style="margin-top: 24px; border-top: 1px solid var(--border-primary); padding-top: 24px;">
            <button id="refresh-btn" class="button">Refresh</button>
            <button id="theme-toggle-btn" class="button">Toggle Theme</button>
            <button id="export-btn" class="button">Export</button>
            <button id="import-btn" class="button">Import</button>
            <input type="file" id="import-file" accept=".json" style="display:none">
        </div>
    </section>

    <div class="floating-bar">
        <div class="floating-bar-section">
            <h1 class="app-title">Stream Monitor <small>v7.2</small></h1>
            <div id="last-updated" aria-live="polite" title="Last updated time"></div>
            <div class="status-indicator" id="connection-status" aria-label="Connection status"></div>
        </div>
        <div class="floating-bar-section view-controls">
            <button id="gemini-choice-btn">✨ Help Me Choose</button>
            <div style="flex:1;"></div>
            <button class="view-toggle active" data-view="grid" aria-label="Grid view">Grid</button>
            <button class="view-toggle" data-view="list" aria-label="List view">List</button>
            <button class="view-toggle" id="select-mode-btn" aria-label="Selection mode">Select</button>
        </div>
        <div class="floating-bar-section">
             <button class="icon-btn" id="install-btn" title="Install app" aria-label="Install app" style="display:none">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M10.75 2.75a.75.75 0 00-1.5 0v8.614L6.295 8.235a.75.75 0 10-1.09 1.03l4.25 4.5a.75.75 0 001.09 0l4.25-4.5a.75.75 0 00-1.09-1.03l-2.955 3.129V2.75z" /><path d="M3.5 12.75a.75.75 0 00-1.5 0v2.5A2.75 2.75 0 004.75 18h10.5A2.75 2.75 0 0018 15.25v-2.5a.75.75 0 00-1.5 0v2.5c0 .69-.56 1.25-1.25 1.25H4.75c-.69 0-1.25-.56-1.25-1.25v-2.5z" /></svg>
            </button>
            <button class="settings-toggle" id="settings-toggle" aria-expanded="false">Settings</button>
        </div>
     </div>
     <div class="bulk-actions" id="bulk-actions">
            <span class="selection-count" id="selection-count">0 selected</span>
            <button id="bulk-favorite" class="button">⭐ Favorite</button>
            <button id="bulk-unfavorite" class="button">☆ Unfavorite</button>
            <button id="select-all" class="button">Select All</button>
            <button id="clear-selection" class="button">Clear</button>
    </div>
  </div>
    
  <!-- Modals -->
  <div id="toast" role="alert" aria-live="assertive"></div>
  <div id="gemini-modal" class="modal-overlay">
    <div class="modal-content">
      <button id="gemini-modal-close" class="modal-close" title="Close">&times;</button>
      <h3 id="gemini-modal-title">AI Assistant</h3>
      <div id="gemini-modal-content"><div class="spinner"></div></div>
    </div>
  </div>
  <div id="thumbnail-modal" class="modal-overlay">
      <div class="modal-content">
          <button id="thumbnail-modal-close" class="modal-close">&times;</button>
          <img id="enlarged-thumbnail" src="" alt="Enlarged stream thumbnail">
      </div>
  </div>

<script>
// Utility classes (PWA, Utils, CacheManager)
const PWA = {
  deferredPrompt: null,
  iconCache: {},

  async init() {
    try {
      await this.injectManifest();
      await this.registerServiceWorker();
      this.setupInstallUI();
    } catch (e) {
      console.warn('[PWA] init error:', e);
    }
  },

  async injectManifest() {
    const icon192 = await this.generateIcon(192);
    const icon512 = await this.generateIcon(512);
    const theme = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
    const manifest = {
      name: 'Kick & Twitch Monitor',
      short_name: 'Stream Monitor',
      description: 'Monitor your favorite streamers.',
      start_url: '.',
      display: 'standalone',
      background_color: getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim(),
      theme_color: theme,
      icons: [
        { src: icon192, sizes: '192x192', type: 'image/png', purpose: 'any maskable' },
        { src: icon512, sizes: '512x512', type: 'image/png', purpose: 'any maskable' }
      ]
    };
    const blob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const manifestLink = document.createElement('link');
    manifestLink.rel = 'manifest';
    manifestLink.href = url;
    document.head.appendChild(manifestLink);

    // Explicitly add favicon link
    const faviconLink = document.createElement('link');
    faviconLink.rel = 'icon';
    faviconLink.type = 'image/png';
    faviconLink.href = icon192;
    document.head.appendChild(faviconLink);
  },

  async generateIcon(size) {
    if (this.iconCache[size]) return this.iconCache[size];
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const ctx = c.getContext('2d');
    const grad = ctx.createLinearGradient(0, 0, size, size);
    grad.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim());
    grad.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue('--accent-secondary').trim());
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);
    ctx.fillStyle = '#ffffff';
    ctx.font = `bold ${size * 0.5}px ${getComputedStyle(document.body).fontFamily}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('SM', size / 2, size / 2);
    const url = c.toDataURL();
    this.iconCache[size] = url;
    return url;
  },

  async registerServiceWorker() {
    if (!('serviceWorker' in navigator)) return;
    const swScript = `
        self.addEventListener('install', event => {});
        self.addEventListener('fetch', event => {
            event.respondWith(fetch(event.request));
        });
    `;
    const blob = new Blob([swScript], { type: 'application/javascript' });
    const swUrl = URL.createObjectURL(blob);
    try {
      await navigator.serviceWorker.register(swUrl);
    } catch (err) {
      console.warn('[PWA] SW registration failed:', err);
    }
  },

  setupInstallUI() {
    const installBtn = document.getElementById('install-btn');
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      this.deferredPrompt = e;
      installBtn.style.display = 'inline-grid';
    });
    installBtn.addEventListener('click', async () => {
      if (!this.deferredPrompt) return;
      this.deferredPrompt.prompt();
      const { outcome } = await this.deferredPrompt.userChoice;
      if (outcome === 'accepted') {
        installBtn.style.display = 'none';
      }
      this.deferredPrompt = null;
    });
  }
};
const Utils = {
  debounce(fn, wait){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,a), wait); }; },
  formatNumber(n){ if(!n) return '0'; if(n>=1e6) return (n/1e6).toFixed(1)+'M'; if(n>=1e3) return (n/1e3).toFixed(1)+'K'; return n.toString(); },
  sanitizeHTML(s){ const d=document.createElement('div'); d.textContent=s; return d.innerHTML; },
  formatDuration(m){ if(!m || m < 0) return '0m'; if(m<60) return `${m}m`; const h=Math.floor(m/60), min=m%60; if(h<24) return `${h}h ${min}m`; const d=Math.floor(h/24), rh=h%24; return `${d}d ${rh}h`; },
  calculateUptime(start){ if(!start) return 0; return Math.floor((new Date()-new Date(start))/(1000*60)); },
};
class CacheManager {
  constructor(ttl=60000){ this.cache=new Map(); this.ttl=ttl; }
  set(k,d,ttl=this.ttl){ this.cache.set(k,{d,t:Date.now(),ttl}); }
  get(k){ const it=this.cache.get(k); if(!it) return null; if(Date.now()-it.t>it.ttl){ this.cache.delete(k); return null; } return it.d; }
  clear(){ this.cache.clear(); }
}

/* =================== Gemini API Service =================== */
const Gemini = {
  apiKey: "", // Left empty for automated key injection
  async ask(prompt, retries = 3, delay = 1000) {
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${this.apiKey}`;
    const payload = { contents: [{ parts: [{ text: prompt }] }] };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        if (response.status >= 500 && retries > 0) {
          await new Promise(res => setTimeout(res, delay));
          return this.ask(prompt, retries - 1, delay * 2);
        }
        throw new Error(`API Error: ${response.status} ${response.statusText}`);
      }
      const result = await response.json();
      return result.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I couldn't generate a response.";
    } catch (error) {
       if (retries > 0) {
          await new Promise(res => setTimeout(res, delay));
          return this.ask(prompt, retries - 1, delay * 2);
        }
      console.error("Gemini API call failed:", error);
      throw error;
    }
  }
};


/* =================== Main App Logic =================== */
const App = {
  state:{
    streamers:[], streamerData:new Map(), favorites:[], groups:{},
    isLoading:true, filter:'all', sort:'status', searchQuery:'',
    lastLiveStates: {},
    selectionMode: false, selectedStreamers: new Set(),
    workerEndpoint: 'https://autumn-base-826c.rapahannock.workers.dev/',
    workerAuthToken: 'oK2ZrKag8*R7Wr*UgMBrFdcD6',
    autoRefreshInterval: null,
    autoRefreshDelay: 300000, // Default 5 minutes
    toastTimeout: null,
    BANNED_PLACEHOLDER_THUMBNAIL: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 9' fill='none' stroke='%23ef4444' stroke-width='1'%3E%3Cpath d='M2 0H14C15.1 0 16 0.9 16 2V7C16 8.1 15.1 9 14 9H2C0.9 9 0 8.1 0 7V2C0 0.9 0.9 0 2 0Z' stroke='none' fill='%2323272d'/%3E%3Ccircle cx='8' cy='4.5' r='3'/%3E%3Cline x1='5.5' y1='2' x2='10.5' y2='7'/%3E%3C/svg%3E",
  },
  
  elements: {},
  cache: new CacheManager(120000), // 2 minute cache

  init(){
    this.cacheElements();
    this.loadSettings();
    this.registerEventListeners();
    this.populateFilterDropdown();
    this.fetchStreamerList();
    this.startAutoRefresh();
  },

  cacheElements(){
    this.elements = {
      container: document.getElementById('streamers'),
      searchInput: document.getElementById('search-input'),
      lastUpdated: document.getElementById('last-updated'),
      statusIndicator: document.getElementById('connection-status'),
      settingsToggle: document.getElementById('settings-toggle'),
      settingsPanel: document.getElementById('settings-panel'),
      settingsOverlay: document.getElementById('settings-overlay'),
      toast: document.getElementById('toast'),
      filterSelect: document.getElementById('filter-select'),
      sortSelect: document.getElementById('sort-select'),
      autoRefreshSelect: document.getElementById('auto-refresh-select'),
      addInput: document.getElementById('add-input'),
      platformSelect: document.getElementById('platform-select'),
      addBtn: document.getElementById('add-btn'),
      selectModeBtn: document.getElementById('select-mode-btn'),
      bulkActions: document.getElementById('bulk-actions'),
      selectionCount: document.getElementById('selection-count'),
      bulkFavoriteBtn: document.getElementById('bulk-favorite'),
      bulkUnfavoriteBtn: document.getElementById('bulk-unfavorite'),
      selectAllBtn: document.getElementById('select-all'),
      clearSelectionBtn: document.getElementById('clear-selection'),
      geminiChoiceBtn: document.getElementById('gemini-choice-btn'),
      geminiModal: document.getElementById('gemini-modal'),
      geminiModalTitle: document.getElementById('gemini-modal-title'),
      geminiModalContent: document.getElementById('gemini-modal-content'),
      geminiModalClose: document.getElementById('gemini-modal-close'),
      thumbnailModal: document.getElementById('thumbnail-modal'),
      enlargedThumbnail: document.getElementById('enlarged-thumbnail'),
      thumbnailModalClose: document.getElementById('thumbnail-modal-close'),
      refreshBtn: document.getElementById('refresh-btn'),
      themeToggleBtn: document.getElementById('theme-toggle-btn'),
      exportBtn: document.getElementById('export-btn'),
      importBtn: document.getElementById('import-btn'),
      importFile: document.getElementById('import-file'),
      installBtn: document.getElementById('install-btn'),
    };
  },

  loadSettings(){
    const theme = localStorage.getItem("theme") || (matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
    document.body.setAttribute("data-theme", theme);
    this.state.favorites = JSON.parse(localStorage.getItem("favorites") || "[]");
    this.state.groups = JSON.parse(localStorage.getItem("groups") || "{}");
    this.state.filter = localStorage.getItem("filter") || 'all';
    this.state.sort = localStorage.getItem("sort") || 'status';
    this.state.autoRefreshDelay = parseInt(localStorage.getItem("autoRefreshDelay") || '300000', 10);
    this.elements.filterSelect.value = this.state.filter;
    this.elements.sortSelect.value = this.state.sort;
    this.elements.autoRefreshSelect.value = this.state.autoRefreshDelay;
    const viewMode = localStorage.getItem("viewMode") || 'grid';
    this.updateViewMode(viewMode);
  },

  registerEventListeners(){
    this.elements.settingsToggle.addEventListener('click', () => this.toggleSettings());
    this.elements.settingsOverlay.addEventListener('click', () => this.toggleSettings());
    this.elements.searchInput.addEventListener('input', Utils.debounce(() => this.render(), 300));
    this.elements.filterSelect.addEventListener('change', e => { this.state.filter = e.target.value; localStorage.setItem('filter', e.target.value); this.render(); });
    this.elements.sortSelect.addEventListener('change', e => { this.state.sort = e.target.value; localStorage.setItem('sort', e.target.value); this.render(); });
    this.elements.autoRefreshSelect.addEventListener('change', e => this.handleAutoRefreshChange(e));
    this.elements.addBtn.addEventListener('click', () => this.addStreamer());

    this.elements.selectModeBtn.addEventListener('click', () => this.toggleSelectionMode());
    this.elements.bulkFavoriteBtn.addEventListener('click', () => this.bulkToggleFavorite(true));
    this.elements.bulkUnfavoriteBtn.addEventListener('click', () => this.bulkToggleFavorite(false));
    this.elements.selectAllBtn.addEventListener('click', () => this.selectAllStreamers());
    this.elements.clearSelectionBtn.addEventListener('click', () => this.clearSelection());

    document.querySelectorAll('.view-toggle[data-view]').forEach(btn => {
      btn.addEventListener('click', e => this.updateViewMode(e.currentTarget.dataset.view));
    });

    this.elements.geminiChoiceBtn.addEventListener('click', () => this.handleRecommendStream());
    this.elements.geminiModal.addEventListener('click', (e) => { if (e.target === e.currentTarget) this.hideGeminiModal(); });
    this.elements.geminiModalClose.addEventListener('click', () => this.hideGeminiModal());

    this.elements.thumbnailModal.addEventListener('click', (e) => { if(e.target === e.currentTarget) this.hideEnlargedThumbnail(); });
    this.elements.thumbnailModalClose.addEventListener('click', () => this.hideEnlargedThumbnail());
    this.elements.enlargedThumbnail.addEventListener('click', e => { 
        const url = e.currentTarget.dataset.streamUrl;
        if(url) window.open(url, '_blank', 'noopener,noreferrer');
    });

    this.elements.refreshBtn.addEventListener('click', () => this.fetchStreamerData());
    this.elements.themeToggleBtn.addEventListener('click', () => this.toggleTheme());
    this.elements.exportBtn.addEventListener('click', () => this.exportList());
    this.elements.importBtn.addEventListener('click', () => this.elements.importFile.click());
    this.elements.importFile.addEventListener('change', e => this.importList(e));
    this.elements.toast.addEventListener('click', () => this.dismissToast());
    
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && this.state.autoRefreshDelay > 0) {
        this.fetchStreamerData(); // Refresh immediately when tab becomes visible
        this.startAutoRefresh();
      } else {
        this.stopAutoRefresh();
      }
    });
  },
  
  toggleSettings() {
      const isExpanded = this.elements.settingsPanel.classList.toggle('expanded');
      this.elements.settingsToggle.setAttribute('aria-expanded', isExpanded);
      this.elements.settingsOverlay.classList.toggle('visible', isExpanded);
  },

  handleAutoRefreshChange(event) {
    this.state.autoRefreshDelay = parseInt(event.target.value, 10);
    localStorage.setItem('autoRefreshDelay', this.state.autoRefreshDelay);
    this.startAutoRefresh();
    const friendlyTime = event.target.options[event.target.selectedIndex].text;
    this.showToast(`Auto-refresh set to ${friendlyTime.toLowerCase()}`, 'info');
  },

  startAutoRefresh() {
    this.stopAutoRefresh();
    if (this.state.autoRefreshDelay > 0) {
      this.state.autoRefreshInterval = setInterval(() => {
        if (!document.hidden) {
          this.fetchStreamerData();
        }
      }, this.state.autoRefreshDelay);
    }
  },

  stopAutoRefresh() {
    if (this.state.autoRefreshInterval) {
      clearInterval(this.state.autoRefreshInterval);
      this.state.autoRefreshInterval = null;
    }
  },

  populateFilterDropdown(){
    const defs = `<option value="all">All</option><option value="live">Live</option><option value="offline">Offline</option><option value="favorites">Favorites</option>`;
    const groups = Object.keys(this.state.groups).sort().map(n=>`<option value="group-${n}">📂 ${Utils.sanitizeHTML(n)}</option>`).join('');
    this.elements.filterSelect.innerHTML = defs + (groups? '<option disabled>-----</option>'+groups : '');
    this.elements.filterSelect.value = this.state.filter;
  },

  async fetchStreamerList(){
    this.setLoadingState(true);
    this.updateConnectionStatus('connecting');
    try {
      if (this.state.workerAuthToken === 'YOUR_WORKER_AUTH_TOKEN' || !this.state.workerAuthToken) {
        throw new Error('Authentication token is missing. Please check the App.state configuration.');
      }
      const headers = { 'Authorization': `Bearer ${this.state.workerAuthToken}` };
      const res = await fetch(`${this.state.workerEndpoint}?t=${Date.now()}`, { headers });

      if (res.status === 401) throw new Error('Unauthorized (401). Your worker authentication token is incorrect or has expired.');
      if (!res.ok) throw new Error(`Network response was not ok: ${res.status}`);
      
      const data = await res.json();
      this.state.streamers = data.streamers || [];
      this.state.twitchClientId = data.config?.twitchClientId;
      this.state.twitchAccessToken = data.config?.twitchAccessToken;
      this.state.youtubeApiKey = data.config?.youtubeApiKey;
      
      this.updateConnectionStatus('connected');
      await this.fetchStreamerData();
    } catch(err) {
      console.error('Failed to load data from worker:', err);
      this.updateConnectionStatus('error');
      this.setLoadingState(false);
      this.renderErrorState("Failed to Load Streamers", err.message);
    }
  },
  
  async fetchStreamerData() {
    this.setLoadingState(true);
    if (!this.state.streamers.length) {
        this.setLoadingState(false);
        this.render();
        return;
    }
    const promises = this.state.streamers.map(s => this.fetchStreamerInfo(s));
    const results = await Promise.allSettled(promises);
    results.forEach(r => {
      if (r.status === 'fulfilled' && r.value) {
        this.state.streamerData.set(r.value.name, r.value);
      }
    });
    this.setLoadingState(false);
  },

   async fetchStreamerInfo(streamer) {
    const {name, platform} = streamer;
    const k = `api-${platform}-${name}`;
    const c = this.cache.get(k); if (c) return c;
    
    let data;
    try {
        if (platform === 'kick') data = await this.fetchKickStreamer(name);
        else if (platform === 'twitch') data = await this.fetchTwitchStreamer(name);
        else if (platform === 'youtube') data = await this.fetchYouTubeStreamer(name);
        else data = { name, platform, isLive: false, title: "Platform not supported", viewers: 0 };
    } catch(e) {
        console.error(`Failed to fetch data for ${name} on ${platform}:`, e);
        const errorMessage = e.message.includes('403') 
            ? "API Key Error (403)" 
            : "Error fetching data";
        data = { name, platform, isLive: false, title: errorMessage, viewers: 0, url: this.getFallbackUrl(name, platform) };
    }

    this.cache.set(k, data);
    return data;
  },

  getFallbackUrl(name, platform) {
      switch(platform) {
          case 'kick': return `https://kick.com/${name}`;
          case 'twitch': return `https://twitch.tv/${name}`;
          case 'youtube': return `https://www.youtube.com/@${name.replace('@','')}`; // Basic fallback
          default: return '#';
      }
  },
  
  async fetchApi(url, headers = {}) {
    for (let i = 0; i < 3; i++) {
      try {
        const r = await fetch(url, { headers });
        if (r.status === 404) return null;
        if (!r.ok) throw new Error(`API responded with status ${r.status}`);
        return r.json();
      } catch (e) {
        if (i < 2) await new Promise(res => setTimeout(res, 1200));
        else throw e;
      }
    }
  },
  
  async fetchKickStreamer(name) {
    const kickApiUrl = `https://kick.com/api/v1/channels/${encodeURIComponent(name)}`;
    const url = `https://corsproxy.io/?${encodeURIComponent(kickApiUrl)}`;
    const d = await this.fetchApi(url);
    if (!d) return { name, platform: 'kick', isLive: false, title: "Banned / Not Found", url: `https://kick.com/${name}`, viewers: 0, category: null, uptime: 0 };
    const isLive = d.livestream !== null;
    return {
      name, platform: 'kick', isLive,
      title: d.livestream?.session_title || "Offline",
      viewers: d.livestream?.viewer_count || 0,
      category: d.livestream?.categories?.[0]?.name || null,
      thumbnail: d.livestream?.thumbnail?.url?.replace('thumbnail_360p', 'thumbnail_720p') || null,
      url: `https://kick.com/${name}`,
      profilePic: d.user?.profile_pic || '',
      uptime: isLive ? Utils.calculateUptime(d.livestream.created_at) : 0,
    };
  },

  async fetchTwitchStreamer(name) {
    if (!this.state.twitchClientId || !this.state.twitchAccessToken) return { name, platform: 'twitch', isLive: false, title: 'Twitch API keys not set' };
    const headers = { 'Client-ID': this.state.twitchClientId, 'Authorization': `Bearer ${this.state.twitchAccessToken}` };
    const [streamRes, userRes] = await Promise.all([
      this.fetchApi(`https://api.twitch.tv/helix/streams?user_login=${encodeURIComponent(name)}`, headers),
      this.fetchApi(`https://api.twitch.tv/helix/users?login=${encodeURIComponent(name)}`, headers)
    ]);
    const streamData = streamRes?.data?.[0];
    const userData = userRes?.data?.[0];
    if (!userData) return { name, platform: 'twitch', isLive: false, title: 'Not Found' };
    const isLive = !!streamData && streamData.type === 'live';
    return {
      name, platform: 'twitch', isLive,
      title: isLive ? streamData.title : "Offline",
      viewers: isLive ? streamData.viewer_count : 0,
      category: isLive ? streamData.game_name : null,
      thumbnail: isLive ? streamData.thumbnail_url.replace('{width}', '440').replace('{height}', '248') : null,
      url: `https://twitch.tv/${name}`,
      profilePic: userData.profile_image_url || '',
      uptime: isLive ? Utils.calculateUptime(streamData.started_at) : 0,
    };
  },
    
  async fetchYouTubeStreamer(name) {
    if (!this.state.youtubeApiKey) {
      console.warn("YouTube API key not found in the state after fetching config from worker.");
      return { name, platform: 'youtube', isLive: false, title: 'YouTube API key missing' };
    }

    try {
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(name)}&type=channel&key=${this.state.youtubeApiKey}`;
        const searchData = await this.fetchApi(searchUrl);
        const channel = searchData?.items?.[0];

        if (!channel) {
            console.warn(`YouTube channel not found for name: ${name}`);
            return { name, platform: 'youtube', isLive: false, title: 'Channel not found', url: this.getFallbackUrl(name, 'youtube') };
        }
        
        const { channelId } = channel.id;
        const profilePic = channel.snippet.thumbnails.default.url;
        const channelUrl = `https://www.youtube.com/channel/${channelId}`;

        const liveSearchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&eventType=live&type=video&key=${this.state.youtubeApiKey}`;
        const liveData = await this.fetchApi(liveSearchUrl);
        const liveStream = liveData?.items?.[0];

        if (!liveStream) {
            return { name, platform: 'youtube', isLive: false, title: "Offline", profilePic, url: channelUrl, viewers: 0, category: null, uptime: 0 };
        }

        const videoId = liveStream.id.videoId;
        const videoDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails,snippet&id=${videoId}&key=${this.state.youtubeApiKey}`;
        const videoData = await this.fetchApi(videoDetailsUrl);
        const videoDetails = videoData?.items?.[0];

        if (!videoDetails) {
            return { name, platform: 'youtube', isLive: false, title: "Offline", profilePic, url: channelUrl, viewers: 0, category: null, uptime: 0 };
        }

        return {
            name,
            platform: 'youtube',
            isLive: true,
            title: videoDetails.snippet.title || "Live",
            viewers: parseInt(videoDetails.liveStreamingDetails.concurrentViewers || 0, 10),
            category: videoDetails.snippet.tags ? videoDetails.snippet.tags.slice(0, 3).join(', ') : 'General',
            thumbnail: videoDetails.snippet.thumbnails.high?.url || videoDetails.snippet.thumbnails.medium?.url || null,
            url: channelUrl,
            profilePic,
            uptime: Utils.calculateUptime(videoDetails.snippet.publishedAt),
        };
    } catch (error) {
        console.error(`Failed to fetch YouTube data for ${name}:`, error);
        throw error; 
    }
  },

  getFilteredAndSortedData() {
      let data = Array.from(this.state.streamerData.values());
      this.state.searchQuery = this.elements.searchInput.value.toLowerCase();
      
      data = data.filter(s => {
        const searchMatch = !this.state.searchQuery || 
               s.name.toLowerCase().includes(this.state.searchQuery) ||
               (s.title || '').toLowerCase().includes(this.state.searchQuery) ||
               (s.category || '').toLowerCase().includes(this.state.searchQuery);
        if (!searchMatch) return false;
        
        if(this.state.filter.startsWith('group-')){
            const g=this.state.filter.replace('group-','');
            return this.state.groups[g]?.includes(s.name);
        }
        switch(this.state.filter){
            case 'live': return s.isLive;
            case 'offline': return !s.isLive;
            case 'favorites': return this.state.favorites.includes(s.name);
            default: return true;
        }
      });

      return data.sort((a,b) => {
        switch(this.state.sort) {
            case 'viewers': return (b.viewers || 0) - (a.viewers || 0);
            case 'name': return a.name.localeCompare(b.name);
            case 'category': return (a.category || '').localeCompare(b.category || '');
            case 'uptime': return (b.uptime || 0) - (a.uptime || 0);
            case 'status': default:
                if (a.isLive !== b.isLive) return b.isLive ? 1 : -1;
                return (b.viewers || 0) - (a.viewers || 0);
        }
      });
  },

  render(){
    if(this.state.isLoading) return this.renderSkeletons();
    
    const filtered = this.getFilteredAndSortedData();

    this.elements.container.innerHTML = '';
    if (!filtered.length) return this.renderEmptyState();
    
    const frag = document.createDocumentFragment();
    filtered.forEach(s => frag.appendChild(this.createStreamerCard(s)));
    this.elements.container.appendChild(frag);
    this.elements.lastUpdated.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
    this.updateSelectionUI();
  },

  createStreamerCard(s) {
    const div = document.createElement('div');
    const isFav = this.state.favorites.includes(s.name);
    const isSel = this.state.selectedStreamers.has(s.name);
    div.className = `streamer ${s.platform} ${s.isLive ? 'live' : 'offline'} ${isFav ? 'favorite' : ''} ${this.state.viewMode}-view ${isSel ? 'selected' : ''}`;
    div.dataset.name = s.name;
    
    const platformIcon = `<svg class="platform-icon" role="img" viewBox="0 0 24 24" fill="currentColor">${{
        kick: '<path d="M19.43 2.57L4.57 17.43V2.57h14.86M19.43 0H4.57C2.05 0 0 2.05 0 4.57v14.86C0 21.95 2.05 24 4.57 24h14.86c2.52 0 4.57-2.05 4.57-4.57V4.57C24 2.05 21.95 0 19.43 0z"/>',
        twitch: '<path d="M11.571 4.714h1.715v5.143H11.57zm4.714 0h1.715v5.143h-1.715zM6 0L1.714 4.286v15.428h5.143V24l4.286-4.286h3.428L22.286 12V0H6zm14.571 11.143l-3.428 3.428h-3.429l-3 3v-3H6.857V1.714h13.714v9.429z"/>',
        youtube: '<path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>'
    }[s.platform] || ''}</svg>`;

    let thumbnailSrc = s.thumbnail || '';
    if (s.title === 'Banned / Not Found') {
        thumbnailSrc = this.state.BANNED_PLACEHOLDER_THUMBNAIL;
    }
    const defaultThumbnail = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    
    let metaText = 'Offline';
    if (s.isLive) {
        metaText = `${Utils.formatNumber(s.viewers)} viewers - ${Utils.formatDuration(s.uptime || 0)}`;
    } else if (s.title === 'API Key Error (403)') {
        metaText = `<span style="color: var(--warning);">${s.title}</span>`;
    } else if (s.title === 'Banned / Not Found') {
        metaText = `<span style="color: var(--offline);">${s.title}</span>`;
    }

    div.innerHTML = `
      ${this.state.selectionMode ? `<input type="checkbox" class="streamer-checkbox" ${isSel ? 'checked' : ''}>` : ''}
      <div class="thumbnail-container" data-url="${s.url}" data-src="${thumbnailSrc}">
        <img class="thumbnail-preview" src="${thumbnailSrc}" loading="lazy" onerror="this.style.backgroundColor='var(--bg-tertiary)'; this.src='${defaultThumbnail}'"/>
        ${s.isLive ? `<div class="live-indicator">LIVE</div>` : ''}
      </div>
      <div class="streamer-content">
        <div class="streamer-header">
          <img class="streamer-avatar" src="${s.profilePic}" alt="">
          <div class="streamer-name-wrapper">
            <a href="${s.url}" target="_blank" rel="noopener noreferrer" class="streamer-name">${platformIcon} ${Utils.sanitizeHTML(s.name)}</a>
            <div class="stream-meta">${metaText}</div>
          </div>
        </div>
        <p class="stream-title">${Utils.sanitizeHTML(s.title)}</p>
        ${s.category ? `<div class="stream-category">${Utils.sanitizeHTML(s.category)}</div>` : ''}
        <div class="streamer-actions-wrapper">
            <button class="action-menu-toggle" aria-label="More actions">•••</button>
            <div class="actions-drawer">
                <button class="action-btn summarize" data-name="${s.name}" ${!s.isLive ? 'disabled' : ''}>✨ Summarize</button>
                <button class="action-btn favorite ${isFav ? 'active' : ''}" data-name="${s.name}">⭐ Favorite</button>
                <button class="action-btn assign-group" data-name="${s.name}">📂 Group</button>
                <button class="action-btn remove" data-name="${s.name}" data-platform="${s.platform}">🗑️ Remove</button>
            </div>
        </div>
      </div>
    `;
    div.addEventListener('click', e => {
        if (e.target.closest('.thumbnail-container')) {
            const thumb = e.target.closest('.thumbnail-container');
            if (thumb.dataset.src) this.showEnlargedThumbnail(thumb.dataset.src, thumb.dataset.url);
            return;
        }
        if (this.state.selectionMode && !e.target.closest('a, button, .streamer-actions-wrapper')) {
            this.toggleSelection(e.currentTarget.dataset.name);
        }
    });

    const menuToggle = div.querySelector('.action-menu-toggle');
    menuToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        const parentCard = e.currentTarget.closest('.streamer');
        
        // Close other open drawers
        document.querySelectorAll('.streamer.actions-open').forEach(openCard => {
            if(openCard !== parentCard) {
                openCard.classList.remove('actions-open');
            }
        });
        parentCard.classList.toggle('actions-open');
    });

    div.querySelector('.summarize').addEventListener('click', (e) => { e.stopPropagation(); this.handleStreamSummary(e.currentTarget.dataset.name); });
    div.querySelector('.favorite').addEventListener('click', (e) => { e.stopPropagation(); this.toggleFavorite(e.currentTarget.dataset.name); });
    div.querySelector('.assign-group').addEventListener('click', (e) => { e.stopPropagation(); this.showToast("Group functionality not yet re-implemented.", "info"); });
    div.querySelector('.remove').addEventListener('click', (e) => { e.stopPropagation(); this.removeStreamer(e.currentTarget.dataset.name, e.currentTarget.dataset.platform); });
    return div;
  },
  
  toggleSelectionMode() {
    this.state.selectionMode = !this.state.selectionMode;
    if (!this.state.selectionMode) {
        this.state.selectedStreamers.clear();
    }
    this.elements.selectModeBtn.classList.toggle('active', this.state.selectionMode);
    this.elements.bulkActions.classList.toggle('visible', this.state.selectionMode);
    this.render();
  },
  toggleSelection(name) {
    if (this.state.selectedStreamers.has(name)) {
        this.state.selectedStreamers.delete(name);
    } else {
        this.state.selectedStreamers.add(name);
    }
    this.render();
  },
  selectAllStreamers() {
      this.getFilteredAndSortedData().forEach(s => this.state.selectedStreamers.add(s.name));
      this.render();
  },
  clearSelection() {
      this.state.selectedStreamers.clear();
      this.render();
  },
  updateSelectionUI() {
    if (!this.state.selectionMode) return;
    const count = this.state.selectedStreamers.size;
    this.elements.selectionCount.textContent = `${count} selected`;
  },
  bulkToggleFavorite(add) {
    this.state.selectedStreamers.forEach(name => {
        const has = this.state.favorites.includes(name);
        if (add && !has) this.state.favorites.push(name);
        if (!add && has) this.state.favorites = this.state.favorites.filter(f => f !== name);
    });
    localStorage.setItem('favorites', JSON.stringify(this.state.favorites));
    this.render();
  },

  async handleStreamSummary(name) {
    const s = this.state.streamerData.get(name);
    if (!s) return;
    this.showGeminiModal(`Summary for ${s.name}`);
    if (!s.isLive) {
      this.elements.geminiModalContent.innerHTML = `<p>${s.name} is currently offline.</p>`;
      return;
    }
    const prompt = `Act as an enthusiastic stream commentator. Based on the following data for the streamer '${s.name}', write a short, exciting summary (2-3 sentences) of what they are currently streaming. Stream Title: '${s.title}', Game/Category: '${s.category}'.`;
    try {
      const summary = await Gemini.ask(prompt);
      this.elements.geminiModalContent.innerHTML = `<p>${Utils.sanitizeHTML(summary)}</p>`;
    } catch (error) {
      this.elements.geminiModalContent.innerHTML = `<p class="error-text">Could not generate summary. The AI service may be temporarily unavailable.</p>`;
    }
  },
  
  async handleRecommendStream() {
    const liveStreamers = [...this.state.streamerData.values()].filter(s => s.isLive);
    if (liveStreamers.length === 0) {
      this.showToast("No one is live right now!", 'info');
      return;
    }
    this.showGeminiModal("Which stream should I watch?");

    const streamerInfo = liveStreamers
        .map(s => `${s.name} (${s.category || 'Misc'})`)
        .join(', ');
    const prompt = `From the following list of live streamers, who should I watch? Give me one fun, exciting recommendation and a brief reason why. List: ${streamerInfo}.`;
    
    try {
      const recommendation = await Gemini.ask(prompt);
      this.elements.geminiModalContent.innerHTML = `<p>${Utils.sanitizeHTML(recommendation)}</p>`;
    } catch (error) {
      this.elements.geminiModalContent.innerHTML = `<p class="error-text">Could not get a recommendation. The AI service may be temporarily unavailable.</p>`;
    }
  },
  
  showGeminiModal(title) {
    this.elements.geminiModalTitle.textContent = title;
    this.elements.geminiModalContent.innerHTML = '<div class="spinner"></div>';
    this.elements.geminiModal.classList.add('visible');
  },
  hideGeminiModal() {
    this.elements.geminiModal.classList.remove('visible');
  },

  showEnlargedThumbnail(src, url) {
    if (!src) return;
    this.elements.enlargedThumbnail.src = src;
    this.elements.enlargedThumbnail.dataset.streamUrl = url;
    this.elements.thumbnailModal.classList.add('visible');
  },
  hideEnlargedThumbnail() {
    this.elements.thumbnailModal.classList.remove('visible');
  },
  
  toggleFavorite(name) {
    const favs = new Set(this.state.favorites);
    if (favs.has(name)) favs.delete(name);
    else favs.add(name);
    this.state.favorites = [...favs];
    localStorage.setItem('favorites', JSON.stringify(this.state.favorites));
    this.render();
    this.showToast(`${name} ${favs.has(name) ? 'added to' : 'removed from'} favorites.`, 'success');
  },

  toggleTheme() {
    const next = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
    document.body.setAttribute('data-theme', next);
    localStorage.setItem('theme', next);
  },

  exportList() {
      const data = JSON.stringify(this.state.streamers);
      const blob = new Blob([data], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'streamers.json';
      a.click();
      URL.revokeObjectURL(url);
      this.showToast('Exported successfully!', 'success');
  },

  importList(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async (e) => {
          try {
              const imported = JSON.parse(e.target.result);
              if (!Array.isArray(imported)) throw new Error("Invalid format");
              const result = await this.postToWorker({ action: 'bulkReplace', list: imported });
              if (result) {
                  this.showToast('Import successful! Refreshing list...', 'success');
                  await this.fetchStreamerList();
              }
          } catch (err) {
              this.showToast(`Import failed: ${err.message}`, 'error');
          }
      };
      reader.readAsText(file);
      event.target.value = ''; // Reset file input
  },
  
  async addStreamer() {
    const name = this.elements.addInput.value.trim();
    const platform = this.elements.platformSelect.value;
    if (!name) return this.showToast('Please enter a streamer name.', 'warning');

    const result = await this.postToWorker({ action: 'add', name, platform });
    if (result !== null) {
      this.showToast(`${name} added successfully!`, 'success');
      this.elements.addInput.value = '';
      await this.fetchStreamerList();
    }
  },

  async removeStreamer(name, platform) {
    const pin = prompt(`Enter PIN to confirm removal of ${name}:`);
    if (pin === null) { // User clicked cancel
        this.showToast('Removal cancelled.', 'info');
        return;
    }
    // The worker is expected to handle PIN verification.
    const result = await this.postToWorker({ action: 'remove', name, platform, pin });
    if (result !== null) {
      this.showToast(`🗑️ ${name} removed successfully.`, 'success');
      await this.fetchStreamerList();
    }
  },
  
  async postToWorker(body) {
    try {
      if (this.state.workerAuthToken === 'YOUR_WORKER_AUTH_TOKEN' || !this.state.workerAuthToken) {
          throw new Error('Authentication token is missing. Please check the App.state configuration.');
      }
      const res = await fetch(this.state.workerEndpoint, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.state.workerAuthToken}`
        },
        body: JSON.stringify(body)
      });
      const txt = await res.text();
      if (!res.ok) throw new Error(txt || `Worker responded with status ${res.status}`);
      return txt;
    } catch (e) {
      this.showToast(`❌ Action failed: ${e.message}`, 'error');
      return null;
    }
  },

  setLoadingState(isLoading){ this.state.isLoading = isLoading; this.render(); },
  updateConnectionStatus(status){ this.elements.statusIndicator.className = `status-indicator ${status}`; },
  updateViewMode(mode){
      this.state.viewMode = mode;
      localStorage.setItem("viewMode", mode);
      document.querySelectorAll('.view-toggle[data-view]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === mode);
      });
      this.elements.container.className = `${mode}-view`;
      this.render();
  },
  renderSkeletons(){
    this.elements.container.innerHTML = Array(8).fill('').map(() => `
      <div class="streamer skeleton">
        <div style="width:100%; aspect-ratio:16/9; background: var(--bg-tertiary);"></div>
        <div class="streamer-content">
          <div class="streamer-header">
            <div style="width:40px; height:40px; border-radius:50%; background: var(--bg-tertiary);"></div>
            <div style="flex:1;">
              <div style="height:20px; width:60%; background:var(--bg-tertiary); border-radius:6px; margin-bottom:8px;"></div>
              <div style="height:14px; width:40%; background:var(--bg-tertiary); border-radius:6px;"></div>
            </div>
          </div>
          <div style="height:16px; width:90%; background:var(--bg-tertiary); border-radius:6px; margin-top:12px;"></div>
        </div>
      </div>
    `).join('');
  },
  renderEmptyState(){ this.elements.container.innerHTML = `<div class="empty-state"><h3>No Streamers Found</h3><p>No streamers match your current filter, or your list is empty.</p></div>`; },
  renderErrorState(title, message){ this.elements.container.innerHTML = `<div class="error-state"><h3>${title}</h3><p>${message}</p></div>`; },
  
  showToast(msg, type = 'info') {
    const t = this.elements.toast;
    if (!t) return;
    if (this.state.toastTimeout) {
      clearTimeout(this.state.toastTimeout);
    }
    t.textContent = msg;
    t.className = ''; // Clear previous type classes
    t.classList.add(type);
    t.classList.add('show');
    this.state.toastTimeout = setTimeout(() => {
        this.dismissToast();
    }, 5000);
  },

  dismissToast() {
      const t = this.elements.toast;
      if (!t) return;
      t.classList.remove('show');
      if (this.state.toastTimeout) {
          clearTimeout(this.state.toastTimeout);
          this.state.toastTimeout = null;
      }
  }
};

document.addEventListener('DOMContentLoaded', async () => {
  try {
    await PWA.init();
    App.init();
  } catch(e) {
    console.error('Failed to initialize:', e);
    document.body.innerHTML = `<div class="error-state" style="margin:20px;"><h1>Failed to load Monitor</h1><p>${e.message}</p></div>`;
  }
});
</script>
</body>
</html>

